<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Sphere</title>
		<meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <script src="https://threejs.org/build/three.min.js"></script>
        <script src="https://threejs.org/examples/js/controls/TrackballControls.js"></script>
        <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/7.0.1/math.min.js" integrity="sha256-vT3LwbZg753BzMyE25HfnWHVnMOcbuzde2XvX2wuD7U=" crossorigin="anonymous"></script>
	</head>

	<body style="padding: 0; margin: 0;">
		<script type="module">
            let  camera, controls, scene, renderer;
            
            init();           
            animate();

            export function getSpheresForNumberOfBeams(numberOfBeams) {
                let area = 0;
                const identityMatrix = math.identity(3);
                const output = [];
                const angle = Math.PI / numberOfBeams;
                const sinOfAngle = Math.sin(angle);
                const cosOfAngle = Math.cos(angle);
                const factor = (1 - sinOfAngle) / (1 + sinOfAngle);
                const factor1 = (sinOfAngle) / (1 + sinOfAngle);

                let step = 0;
                let sphereRadius = 100;
                let radius = sphereRadius * sinOfAngle / (1 + sinOfAngle);
                let distanceFromCenter = radius / sinOfAngle;
                console.log(sphereRadius, radius, distanceFromCenter)
                const angles = [{
                    tiltAngle: Math.PI/2,
                    rotationAngle: 0,
                    radiusFactor: 1,
                }];
                while (step < 2) {
                    angles.forEach(currentAngles => {
                        const { tiltAngle, rotationAngle, radiusFactor} = currentAngles;

                        area += numberOfBeams * (Math.PI * radius * radius);
                        for (let beam = 0; beam < numberOfBeams; beam++) {
                            const alpha = 2 * angle * beam; 
                            const beta = Math.asin(radius/((sphereRadius-radius)));
                            const cx = distanceFromCenter * Math.cos(alpha) * Math.sin(beta);
                            const cy = distanceFromCenter * Math.sin(alpha) * Math.sin(beta);
                            const cz = distanceFromCenter * Math.cos(beta);
                            console.log('here', radius);

                            const circle =  {
                                cy,
                                cx,
                                cz,
                                radius,
                                angle,
                                beam,
                                numberOfBeams,
                                distanceFromCenter,
                            };

                            output.push(circle);
                        }
                    });
                    
                    // radius = radius * factor;
                    radius = (-2*(Math.sin(angle)))/(Math.cos(2*angle)-3) * sphereRadius;
                    distanceFromCenter = sphereRadius - radius;
                    step++;
                }

                console.log(area);
                return output;
            }


            function init() {
                const spheres = getSpheresForNumberOfBeams(6);  
                scene = new THREE.Scene();
                scene.background = new THREE.Color( 0x111111 );
                // scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );
				scene.add( new THREE.AxesHelper( 100 ) );

                renderer = new THREE.WebGLRenderer( { antialias: false } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                // camera = new THREE.PerspectiveCamera( 100, window.innerWidth / window.innerHeight, 1, 500 );
                const zoom = 6;
                camera = new THREE.OrthographicCamera( window.innerWidth / -zoom, window.innerWidth / zoom, window.innerHeight / zoom, window.innerHeight / -zoom, -100, 100 );
				camera.position.set(0, -1, 1);
                camera.lookAt(new THREE.Vector3(0,0,0)); // Set look at coordinate like this
                // controls

                controls = new THREE.OrbitControls( camera, renderer.domElement );
                controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)
                

                // controls.minDistance = 5;
                // controls.maxDistance = 500;

                // controls.maxPolarAngle = 2 * Math.PI;
                // controls = new THREE.TrackballControls( camera, renderer.domElement );
                // controls.addEventListener( 'change', render );

				// controls.rotateSpeed = 1.0;
				// controls.zoomSpeed = 1.2;    
                // controls.panSpeed = 0.8;
                // controls.keys = [ 65, 83, 68 ];


                // world

                let material = new THREE.MeshPhongMaterial( { color: 0xffffff, transparent: true, opacity: 0.5 } );
                let basicMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, transparent: true, opacity: 0.9 } );

                spheres.forEach(sphereObj => {
                    let geometry = new THREE.SphereGeometry( sphereObj.radius, 32, 32 );
                    let sphere = new THREE.Mesh( geometry, material );
                    sphere.position.x = sphereObj.cx;
                    sphere.position.y = sphereObj.cy;
                    sphere.position.z = sphereObj.cz;
                    sphere.updateMatrix();
                    sphere.matrixAutoUpdate = false;
                    geometry.center();
                    sphere.addEventListener( 'click', (ev) => sphere.visible = false );
                    scene.add( sphere );
                })

                // lights

                let light1 = new THREE.DirectionalLight( 0xffffff );
                light1.position.set( 0, 10, 0 );
                scene.add( light1 );

                let light2 = new THREE.DirectionalLight( 0xffffff );
                light2.position.set( 0, -10, 0 );
                scene.add( light2 );

                window.addEventListener( 'resize', onWindowResize, false );

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function animate() {

                // requestAnimationFrame( animate );

                // controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

                render();

            }

            function render() {
                renderer.render( scene, camera );
            }
		</script>
	</body>
</html>