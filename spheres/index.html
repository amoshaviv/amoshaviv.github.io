<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Sphere</title>
		<meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <script src="https://threejs.org/build/three.min.js"></script>
        <script src="https://threejs.org/examples/js/controls/TrackballControls.js"></script>
        <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
	</head>

	<body style="padding: 0; margin: 0;">
		<script type="module">
            let  camera, controls, scene, renderer;
            
            init();           
            animate();

            export function getSpheresForNumberOfBeams(numberOfBeams) {
                let area = 0;
                const output = [];
                const angle = Math.PI / numberOfBeams;
                const sinOfAngle = Math.sin(angle);
                const cosOfAngle = Math.cos(angle);
                const factor = (1 - sinOfAngle) / (1 + sinOfAngle);

                let step = 0;
                let sphereRadius = 100;
                let radius = sphereRadius * sinOfAngle / (1 + sinOfAngle);
                let distanceFromCenter = radius / sinOfAngle;
                const angles = [0, 1, 2, 3, 4, 5];
                while (radius > 1) {
                    angles.forEach(skewAngle => {
                        area += numberOfBeams * (Math.PI * radius * radius);
                        for (let beam = 0; beam <= numberOfBeams / 2; beam++) {
                            const cx = distanceFromCenter * Math.cos(4 * skewAngle * Math.PI / numberOfBeams) * Math.sin(2 * angle * beam);
                            const cy = distanceFromCenter * Math.sin(4 * skewAngle * Math.PI / numberOfBeams) * Math.sin(2 * angle * beam);
                            const cz = distanceFromCenter * Math.cos(2 * angle * beam);
                            const circle =  {
                                cy,
                                cx,
                                cz,
                                radius,
                                angle,
                                beam,
                                numberOfBeams,
                                distanceFromCenter,
                            };

                            output.push(circle);
                            if (beam > 0) {
                                if (skewAngle === 0) {
                                    const extraCircle = Object.assign({}, circle);
                                    extraCircle.cz = -1 * circle.cy;
                                    extraCircle.cy = circle.cz;
                                    output.push(extraCircle);
                                } else if (skewAngle === 3) {
                                    const extraCircle = Object.assign({}, circle);
                                    extraCircle.cy = -1 * circle.cz;
                                    extraCircle.cz = circle.cy;
                                    output.push(extraCircle);
                                } 
                            }
                        }
                    });
                    
                    radius = radius * factor;
                    distanceFromCenter = distanceFromCenter * factor;
                    step++;
                }

                console.log(area);
                return output;
            }


            function init() {
                const spheres = getSpheresForNumberOfBeams(12);  
                scene = new THREE.Scene();
                scene.background = new THREE.Color( 0x111111 );
                // scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );
				scene.add( new THREE.AxesHelper( 100 ) );

                renderer = new THREE.WebGLRenderer( { antialias: false } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                // camera = new THREE.PerspectiveCamera( 100, window.innerWidth / window.innerHeight, 1, 500 );
                camera = new THREE.OrthographicCamera( window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -500, 500 );
				camera.position.set(100, 100, 0);
                // camera.lookAt(new THREE.Vector3(0,0,0)); // Set look at coordinate like this
                // controls

                controls = new THREE.OrbitControls( camera, renderer.domElement );
                controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

                // controls.minDistance = 5;
                // controls.maxDistance = 500;

                // controls.maxPolarAngle = 2 * Math.PI;
                // controls = new THREE.TrackballControls( camera, renderer.domElement );
                // controls.addEventListener( 'change', render );

				// controls.rotateSpeed = 1.0;
				// controls.zoomSpeed = 1.2;
                // controls.panSpeed = 0.8;
                // controls.keys = [ 65, 83, 68 ];


                // world

                let material = new THREE.MeshPhongMaterial( { color: 0xffffff, transparent: true, opacity: 0.5 } );
                let basicMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, transparent: true, opacity: 0.9 } );

                spheres.forEach(sphereObj => {
                    let geometry = new THREE.SphereGeometry( sphereObj.radius, 32, 32 );
                    let sphere = new THREE.Mesh( geometry, material );
                    sphere.position.x = sphereObj.cx;
                    sphere.position.y = sphereObj.cy;
                    sphere.position.z = sphereObj.cz;
                    sphere.updateMatrix();
                    sphere.matrixAutoUpdate = false;
                    geometry.center();
                    sphere.addEventListener( 'click', (ev) => sphere.visible = false );
                    scene.add( sphere );
                })

                // lights

                let light1 = new THREE.DirectionalLight( 0xffffff );
                light1.position.set( 0, 10, 0 );
                scene.add( light1 );

                let light2 = new THREE.DirectionalLight( 0xffffff );
                light2.position.set( 0, -10, 0 );
                scene.add( light2 );

                window.addEventListener( 'resize', onWindowResize, false );

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function animate() {

                // requestAnimationFrame( animate );

                // controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

                render();

            }

            function render() {
                console.log('HERE')
                renderer.render( scene, camera );

            }
		</script>
	</body>
</html>